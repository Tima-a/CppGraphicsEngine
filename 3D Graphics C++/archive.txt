//Multiple Windows
#include <windows.h>
#include "utility.cpp"
#include <cmath>

#define delta_time_equalization 1000000
#define white 0xffffff
#define green 0x00ff00
#define red 0xff0000
#define blue 0x0000ff
#define yellow 0xffff00
#define black 0
#define PIXEL_SIZE 0.01f
#define pi 3.14f
#define d_pi 6.28f
static bool running = true;

int win_width[10] = { 800, 800, 800, 800, 800, 800, 800, 800, 800, 800 };
int win_height[10] = { 600, 600, 600, 600, 600, 600, 600, 600, 600, 600 };
LPCTSTR win_names[10] = { "ok","ok2", "ok3", "ok4", "ok5", "ok6", "ok7", "ok8", "ok9", "ok10" };
//10 is maximum amount of windows
int win_count = 5;
void* win_memories[10];
int bitmap_width[10];
int bitmap_height[10];
BITMAPINFO bitmap_info[10];
//HWND hWnd = FindWindow("Game Window Class", window_name);

static struct gTime
{
	float delta_time;
};
gTime gtime;

//#include <vector>
//template <class T>
//std::vector<T> name;
#include "renderering.cpp"
#include <time.h>
#include "game.cpp"

LRESULT CALLBACK Window_callback(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	//This is function which sends a message when something important is happened(input, minimize, maximize, size changed
	LRESULT result = 0;
	switch (uMsg)
	{
	case WM_CLOSE:
	case WM_DESTROY:
	{
		running = false;
	}
	break;
	case WM_SIZE:
	{
		RECT rect[10];
		int size[10];
		for (int i = 0; i < win_count; i++)
		{
			GetClientRect(hwnd, &rect[i]);
			bitmap_width[i] = rect[i].right - rect[i].left;
			bitmap_height[i] = rect[i].bottom - rect[i].top;
			size[i] = bitmap_width[i] * bitmap_height[i] * sizeof(unsigned int);

			if (win_memories[i])
			{
				VirtualFree(win_memories[i], 0, MEM_RELEASE);
			}
			win_memories[i] = VirtualAlloc(0, size[i], MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
			bitmap_info[i].bmiHeader.biSize = sizeof(bitmap_info[i].bmiHeader);
			bitmap_info[i].bmiHeader.biWidth = bitmap_width[i];
			bitmap_info[i].bmiHeader.biHeight = bitmap_height[i];
			bitmap_info[i].bmiHeader.biPlanes = 1;
			bitmap_info[i].bmiHeader.biBitCount = 32;
			bitmap_info[i].bmiHeader.biCompression = BI_RGB;
		}
	}
	default:
	{
		result = DefWindowProc(hwnd, uMsg, wParam, lParam);
	}
	}
	return result;
}
int WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
	//Creating Window(or Window class)
	WNDCLASS window_class = {};
	window_class.style = CS_HREDRAW || CS_VREDRAW; //CS_HREDRAW - Horizontal; CS_VREDRAW - Vertical 
	window_class.lpszClassName = "Game Window Class";
	window_class.lpfnWndProc = Window_callback;

	//Register Class
	RegisterClass(&window_class);
	HWND windows[10];
	HDC hdcs[10];
	for (int i = 0; i < win_count; i++)
	{
		windows[i] = CreateWindow(window_class.lpszClassName, win_names[i], WS_OVERLAPPEDWINDOW | WS_VISIBLE, CW_USEDEFAULT, CW_USEDEFAULT, win_width[i], win_height[i], 0, 0, hInstance, 0);
		hdcs[i] = GetDC(windows[i]);
	}
	float delta_time = 0.016666f;
	LARGE_INTEGER frame_begin_time;
	QueryPerformanceCounter(&frame_begin_time);

	float perfomance_frequency;
	{
		LARGE_INTEGER perfomance;
		QueryPerformanceCounter(&perfomance);
		perfomance_frequency = (float)perfomance.QuadPart;
	}

	while (running)
	{
		//Input
		MSG messages[10];
		for (int j = 0; j < win_count; j++)
		{
			while (PeekMessage(&messages[j], windows[j], 0, 0, PM_REMOVE))
			{
				TranslateMessage(&messages[j]);
				DispatchMessage(&messages[j]);
			}
		}
		//Simulate
		simulategame();
		//Creating Window
		for (int z = 0; z < win_count; z++)
		{
			StretchDIBits(hdcs[z], 0, 0, win_width[z], win_height[z], 0, 0, win_width[z], win_height[z], win_memories[z], &bitmap_info[z], DIB_RGB_COLORS, SRCCOPY);
		}
		LARGE_INTEGER frame_end_time;
		QueryPerformanceCounter(&frame_end_time);
		gtime.delta_time = ((float)(frame_end_time.QuadPart - frame_begin_time.QuadPart) / perfomance_frequency) * delta_time_equalization; //delta time in 1s
		frame_begin_time = frame_end_time;
	}
}
//Multiple Windows